import { $EventOptions, $MutArg } from "../event-base/index.js";
import { $InnerAnyHandler, MapEventEmitter } from "../event-map_emitter/index.js";
import { $EventWaitterMap } from "./index.js";
import { $EmptyObject } from "../typings/$types.js";
export declare class MapEventEmitterPro<EM = $EmptyObject, EM2 = never> extends MapEventEmitter<EM, EM2> {
    /**
     * 触发事件
     * @param eventname
     * @param args
     */
    protected _emit<K extends keyof this["TYPE"]>(eventname: K, args: $MutArg<this["TYPE"][K]>): void;
    /**
     * 移除所有的事件
     */
    clear(opts?: {
        ignoreCommonErrorHanlder?: boolean;
        ignoreBeforeTask?: boolean;
        ignoreAfterTask?: boolean;
        ignoreCustomErrorHanlder?: boolean;
    }): void;
    /**是否有过监听通用事件处理 */
    private _hasCommonEmitHandlerMap?;
    private get _commonEmitHandlerMap();
    /**
     * 监听所有事件
     * @param commonHanlder
     * @param taskname
     */
    onEmit(commonHanlder: $InnerAnyHandler<this["TYPE"]>, opts?: $EventOptions): void;
    /**
     * 移除所有事件的监听
     * @param commonHanlder
     */
    offEmit(commonHanlder: $InnerAnyHandler<this["TYPE"]>): boolean;
    /**是否有使用过after监听器 */
    private _hasAfterTaskMap?;
    private get _afterTasks();
    /**
     * 与once不同，返回promise
     * 这里与常规的监听不同，不需要提供回调函数
     * 在清理事件的时候，它会被触发abort事件
     *
     * 这样设计是因为once事件的行为往往不是为了处理一个事件
     * 而是在等待一个事件，如果基于回调，很容易在清理掉事件的时候，伴随着也将这种等待也清理了
     * 从而陷入了无限的等待，而这往往不是我们所要的
     *
     * 我们当然可以在on函数上增加“被清理时的回调”，这将会更加通用，但同时也意味着清理行为的复杂性增加
     * 我们不需要为那2%的功能牺牲太多，取舍之间，我们选择这样的简单方案来定义`once`的行为
     *
     * @param eventname
     * @param handler
     * @param taskname
     */
    after<K extends keyof this["TYPE"]>(eventname: K): Promise<this["TYPE"][K]>;
    /**
     * 中断一次性监听器
     * @param eventname
     * @param err
     */
    abortAfter<K extends keyof this["TYPE"]>(eventname: K, err: unknown): $EventWaitterMap<this["TYPE"]>[K];
    /**是否有使用过before监听器 */
    private _hasBeforeTaskMap?;
    private get _beforeTasks();
    /**
     * 与after类似，只是触发的时机不同
     *
     * @param eventname
     * @param handler
     * @param taskname
     */
    before<K extends keyof this["TYPE"]>(eventname: K): Promise<this["TYPE"][K]>;
    /**
     * 中断一次性监听器
     * @param eventname
     * @param err
     */
    abortBefore<K extends keyof this["TYPE"]>(eventname: K, err: unknown): $EventWaitterMap<this["TYPE"]>[K];
}
