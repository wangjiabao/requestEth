import { $PromiseMaybe } from "../typings/$types.js";
declare type ParallelExector<T> = () => $PromiseMaybe<T>;
declare type YieldParallelOptions = {
    ignoreError?: boolean;
    onError?: (err: unknown) => unknown;
};
/**
 * 并发池
 */
export declare class ParallelPool<T = any> {
    maxParallelNum: number;
    constructor(maxParallelNum?: number);
    /**正在执行中的任务集合 */
    private _runningTasks;
    /**等待执行队列 */
    private _waitingQuene;
    addTaskExecutor(executor: ParallelExector<T>): Promise<T>;
    /**
     * 知否执行完毕
     */
    get isDone(): boolean;
    /**
     * 是否还有任务
     * 和isDone是反义关系
     */
    get hasTask(): boolean;
    /**
     * 现在队列是否是满的
     * 可以用来判断是否还应该添加任务
     */
    get isFull(): boolean;
    /**执行一条并发线 */
    private _startParallel;
    /**
     * Like `Promise.all`
     * @param opts
     */
    doAll(opts?: YieldParallelOptions): Promise<T[]>;
    /**
     * Like `Promise.race`
     * @param opts
     */
    doRace(opts?: YieldParallelOptions): Promise<T | undefined>;
    private _yielding?;
    /**
     * ## 使用异步迭代器持续地输出并发执行的任务.
     * **虽然这是一个单个出口的函数，当内部会尽量保持声明的并发数来进行任务执行。**
     *
     * ### 比如说：
     * 1. 我并发5条任务线，这时候`yield`到外部了，等待外部响应。
     * 2. 这时候并发器内部在执行着任务，外部没有去给它响应，但它仍旧执行着，直到`5`个并发的任务执行完了。
     * 3. 这时候它会暂停下来。这是维持了一个异步迭代器的初衷：**我停止迭代了，也就不再消耗资源了**。
     * 4. 但如果这个时候继续迭代下去，比如只迭代了`1`次，那么就会有`1`个并发线继续启动。
     * 5. 不会因为一次迭代而再次启用5个任务线。
     *
     * **也就是说，缓冲区的大小和并发数是对等的。**
     *
     * ### 综上所述，我们还可以衍生出这样操作：
     * 1. 在上述例子中，在`3.`之后，我们将`maxParallelNum`设置为`0`
     * 2. 而后我们再去执行`4.`。这时候就不会再有并发线再被启动
     *
     * ### 注意事项
     * 1. 从这里开始，后续添加任务也会被自动执行，直到任务都执行完毕后会自动完结。
     * 2. 所以如果在完结后再添加任务的话，需要手动再进行重启迭代
     * 3. 有且只能有一个迭代器在执行
     */
    yieldResults(opts?: YieldParallelOptions): AsyncGenerator<T, any, unknown>;
    private _yieldResults;
}
export {};
