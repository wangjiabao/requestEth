import { EVENT_DESCRIPTION_SYMBOL, $EventOptions, $MutArg, $MutArgEventHandler } from "../event-base/index.js";
import { $EventEmitterMix, $OnceEventOptions, $InnerErrorHandler } from "./$types.js";
export declare class MapEventEmitter<EM = {}, EM2 = never, EMX extends EM | EM2 = EM | EM2> implements $EventEmitterMix<EM, EM2> {
    /**导出类型 */
    TYPE: EMX;
    private _e;
    /**
     * 监听事件
     * 在这里重复的事件不会被重复监听
     * 原因时我们不支持context对象的绑定，一个函数被重复监听，往往是绑定着不同的this对象，使得上下文的值不一样
     * 这里不允许自定义context对象。就意味着函数被重复监听已经是没有必要的事情
     * 如果由类似的需要，需要执行生成一个闭包，这也将重新生成一个新的函数
     * @param eventname
     * @param handler
     * @param taskname
     */
    on<K extends keyof EM>(eventname: K, handler: $MutArgEventHandler<EM[K]>, opts?: $EventOptions): void;
    on<K extends keyof EM2>(eventname: K, handler: $MutArgEventHandler<EM2[K]>, opts?: $EventOptions): void;
    /** on函数的具体实现 */
    private _on;
    /**一次性事件监听 */
    once<K extends keyof EM>(eventname: K, handler: $MutArgEventHandler<EM[K]>, opts?: $OnceEventOptions): unknown;
    once<K extends keyof EM2>(eventname: K, handler: $MutArgEventHandler<EM2[K]>, opts?: $OnceEventOptions): unknown;
    /**
     * 移除指定处理函数或者选定的事件集合
     * @param eventname
     * @param handler
     */
    off<K extends keyof EM>(eventname: K, handler?: $MutArgEventHandler<EM[K]>): boolean;
    off<K extends keyof EM2>(eventname: K, handler?: $MutArgEventHandler<EM2[K]>): boolean;
    private _off;
    get [EVENT_DESCRIPTION_SYMBOL](): string;
    emit<K extends keyof EM>(eventname: K, ...data: $MutArg<EM[K]>): void;
    emit<K extends keyof EM2>(eventname: K, ...data: $MutArg<EM2[K]>): void;
    protected _emit<EN extends keyof this["TYPE"]>(eventname: EN, args: $MutArg<EMX[EN]>): void;
    /**
     * 触发内部的异常处理函数
     * @param err
     * @param han
     * @param name
     */
    protected _emitErrorHanlder<K extends keyof this["TYPE"]>(err: unknown, eventname: K, args: $MutArg<EMX[K]>): void;
    /**是否由过自定义异常处理 */
    private _hasEmitErrorHandlerSet?;
    private get _emitErrorHandlerSet();
    /**
     * 自定义函数执行异常处理器
     * @param errorHandler
     */
    onError(errorHandler: $InnerErrorHandler<EMX>, taskname?: string): void;
    /**
     * 移除自定义函数的执行异常处理器
     * @param errorHandler
     */
    offError(errorHandler?: $InnerErrorHandler<EMX>): boolean;
    /**
     * 移除所有的事件
     */
    clear(opts?: {
        ignoreCustomErrorHanlder?: boolean;
    }): void;
    get removeAllListeners(): (opts?: {
        ignoreCustomErrorHanlder?: boolean | undefined;
    }) => void;
    get addListener(): {
        <K extends keyof EM>(eventname: K, handler: $MutArgEventHandler<EM[K]>, opts?: $EventOptions | undefined): void;
        <K_1 extends keyof EM2>(eventname: K_1, handler: $MutArgEventHandler<EM2[K_1]>, opts?: $EventOptions | undefined): void;
    };
    get removeListener(): {
        <K extends keyof EM>(eventname: K, handler?: $MutArgEventHandler<EM[K]> | undefined): boolean;
        <K_1 extends keyof EM2>(eventname: K_1, handler?: $MutArgEventHandler<EM2[K_1]> | undefined): boolean;
    };
}
