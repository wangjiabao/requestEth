import { $EventOptions, $MutArgEventHandler } from "../event-base/$types.js";
export interface $QueneEventEmitter<EM extends $EventInOutMap = {}> {
    on<K extends keyof EM>(eventname: K, handler: $InOutEventHandler<EM[K]>, opts?: $EventOptions): unknown;
    once<K extends keyof EM>(eventname: K, handler: $InOutEventHandler<EM[K]>, opts?: Omit<$EventOptions, "once">): unknown;
    has<K extends keyof EM>(eventname: K, handler?: $InOutEventHandler<EM[K]>): boolean;
    off<K extends keyof EM>(eventname: K, handler: $InOutEventHandler<EM[K]>): boolean;
    emit<K extends keyof EM>(eventname: K, data: EM[K]["in"]): EM[K]["out"] | Promise<EM[K]["out"]> | undefined;
    emitToAsyncGenerator<K extends keyof EM>(eventname: K, data: EM[K]["in"]): AsyncGenerator<unknown, void | EM[K]["out"], unknown>;
    TYPE: EM;
}
export interface $SyncQueneEventEmitter<EM extends $EventInOutMap = {}> extends $QueneEventEmitter<EM> {
    on<K extends keyof EM>(eventname: K, handler: $InOutSyncEventHandler<EM[K]>, opts?: $EventOptions): void;
    has<K extends keyof EM>(eventname: K, handler?: $InOutSyncEventHandler<EM[K]>): boolean;
    off<K extends keyof EM>(eventname: K, handler: $InOutSyncEventHandler<EM[K]>): boolean;
    emit<K extends keyof EM>(eventname: K, data: EM[K]["in"]): EM[K]["out"] | undefined;
}
export declare type $EventInOut<I = unknown, O = void> = {
    in: I;
    out: O;
};
export declare type $UnknownEventInOut = $EventInOut<unknown, unknown>;
export declare type $EventHandler<A = unknown, R = void> = (data: A, next: () => R | Promise<R>) => R | Promise<R> | AsyncGenerator<unknown, R> | Generator<unknown, R>;
export declare type $SyncEventHandler<A = unknown, R = void> = (data: A, next: () => R) => R;
export declare type $InOutSyncEventHandler<IO extends $UnknownEventInOut> = $SyncEventHandler<IO["in"], IO["out"]>;
export declare type $InOutEventHandler<IO extends $UnknownEventInOut> = $EventHandler<IO["in"], IO["out"]>;
export declare type $EventInOutMap = {
    [key: string]: $UnknownEventInOut;
};
export declare type $EventInOutHanldersMap<EM extends $EventInOutMap> = {
    [key in keyof EM]?: Map<$InOutEventHandler<EM[key]>, $EventOptions>;
};
declare type $InnerErrorInOutHandlerArg<EM extends $EventInOutMap, K extends keyof EM = keyof EM> = [
    unknown,
    {
        eventname: K;
        arg: EM[K]["in"];
    }
];
export declare type $InnerErrorInOutHandler<EM extends $EventInOutMap> = $MutArgEventHandler<$InnerErrorInOutHandlerArg<EM>>;
declare type _IOEM_To_Object<EM extends $EventInOutMap> = {
    [K in keyof EM]: {
        eventname: K;
        args: EM[K]["in"];
    };
};
export declare type $InnerAnyInOutHandlerArg<EM extends $EventInOutMap> = [
    _IOEM_To_Object<EM>[keyof _IOEM_To_Object<EM>]
];
export declare type $InnerAnyInOutHandler<EM extends $EventInOutMap> = $MutArgEventHandler<$InnerAnyInOutHandlerArg<EM>>;
export {};
