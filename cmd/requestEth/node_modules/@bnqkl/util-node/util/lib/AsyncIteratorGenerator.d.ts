import { $EventInOut } from "../../event-quene_emitter/$types.js";
import { QueneEventEmitter } from "../../event/index.js";
import { $AllArgument } from "../../typings/index.js";
/**异步迭代器生成器，@WZX 可能会用到 */
export declare class AsyncIteratorGenerator<T> extends QueneEventEmitter<{
    requestAll: $EventInOut<void>;
    requestItem: $EventInOut</* index */ number, void>;
    push: $EventInOut<{
        item: T;
        index: number;
    }, void>;
    pushCalc: $EventInOut<{
        calc: () => T;
        index: number;
    }, void>;
    done: $EventInOut<void>;
    error: $EventInOut<unknown>;
}> {
    readonly list: T[];
    /**下一个坐标的最小值 */
    min_next_index: number;
    canPush(index: number): boolean;
    push(item: T, index?: number): void | Promise<void> | undefined;
    private calcs;
    pushCalc(calc: () => T, index?: number): void | Promise<void> | undefined;
    get is_done(): boolean;
    private _is_rejected;
    private _is_resolved;
    private _task?;
    private _initTask;
    done(): Promise<void>;
    private _reason?;
    throw(err: unknown): void | Promise<void>;
    resolve(): Promise<void>;
    reject(err: unknown): void | Promise<void>;
    then(...args: $AllArgument<Promise<T[]>["then"]>): Promise<unknown>;
    catch(...args: $AllArgument<Promise<T[]>["catch"]>): Promise<unknown>;
    private _requestProcess;
    get requestProcess(): number;
    [Symbol.asyncIterator](): {
        index: number;
        return(): Promise<{
            done: true;
            value: undefined;
        }>;
        next(): Promise<{
            done: boolean;
            value: T;
        }>;
    };
    toAsyncIterableIterator(): AsyncGenerator<Awaited<T>, void, unknown>;
}
declare type ComplexObj<D, E> = {
    [key in keyof Omit<D, keyof E>]?: D[key];
} & E;
declare type FilterMapDefault = {
    filter?: false;
    map?: unknown;
    maps?: unknown;
    multi?: false;
};
declare type FilterMap<T> = Readonly<FilterMapDefault | ComplexObj<FilterMapDefault, {
    filter: true;
    map: T;
}> | ComplexObj<FilterMapDefault, {
    filter: true;
    maps: T[];
    multi: true;
}>>;
export declare type AsyncMaybeFilterMap<T> = (FilterMap<T> & {
    async?: false;
}) | {
    async: true;
    value: PromiseLike<FilterMap<T>>;
};
/**
 * 管道转移工具，使用 filterMap 哲学
 * @param sourceAg
 * @param filter
 * @param map
 * @param destAg
 */
export declare const AsyncIteratorGeneratorTransfer: <F, T>(sourceAg: AsyncIteratorGenerator<F>, destAg: AsyncIteratorGenerator<T>, filterMap: (item: F) => AsyncMaybeFilterMap<T>) => void;
export {};
