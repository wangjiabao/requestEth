import { __decorate, __metadata } from "tslib";
import { bindThis } from "../../decorator/index.js";
import { QueneEventEmitter } from "../../event/index.js";
import { PromiseOut } from "../../extends-promise-out/index.js";
import { $ignoreAwait } from "../../typings/index.js";
/**异步迭代器生成器，@WZX 可能会用到 */
export class AsyncIteratorGenerator extends QueneEventEmitter {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "list", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**下一个坐标的最小值 */
        Object.defineProperty(this, "min_next_index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "calcs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_is_rejected", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_is_resolved", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_task", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_reason", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_requestProcess", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    canPush(index) {
        return !(index < this.min_next_index || index in this.list || this.is_done);
    }
    push(item, index = this.min_next_index) {
        if (index < this.min_next_index) {
            throw new RangeError(`push into wrong index:${index}, should be ${this.min_next_index}`);
        }
        if (index in this.list || index in this.calcs) {
            throw new TypeError(`index:${index} already have value`);
        }
        this.list[index] = item;
        while (this.list[this.min_next_index]) {
            this.min_next_index += 1;
        }
        return this.emit("push", { item, index });
    }
    pushCalc(calc, index = this.min_next_index) {
        if (index < this.min_next_index) {
            throw new RangeError(`push into wrong index:${index}, should be ${this.min_next_index}`);
        }
        if (index in this.list || index in this.calcs) {
            throw new TypeError(`index:${index} already have value`);
        }
        const setListCalc = () => {
            delete this.calcs[index];
            const item = (this.list[index] = calc());
            this.emit("push", { item, index });
            return item;
        };
        this.calcs[index] = setListCalc;
        while (this.list[this.min_next_index]) {
            this.min_next_index += 1;
        }
        return this.emit("pushCalc", { calc: setListCalc, index });
    }
    get is_done() {
        return this._is_rejected || this._is_resolved;
    }
    _initTask() {
        let task = this._task;
        if (!task) {
            task = this._task = new PromiseOut();
            if (this._is_rejected) {
                task.reject(this._reason);
            }
            else if (this._is_resolved) {
                task.resolve(this.list);
            }
            else {
                this._requestProcess = Infinity;
                this.emit("requestAll", undefined);
            }
        }
        return task.promise;
    }
    //  = new PromiseOut<T[]>();
    async done() {
        if (!this.is_done) {
            this._is_resolved = true;
            this._task?.resolve(this.list);
            do {
                const calcKeys = new Set(Object.keys(this.calcs));
                if (calcKeys.size === 0) {
                    break;
                }
                await new Promise((resolve, reject) => {
                    const off = () => {
                        this.off("push", afterCalc);
                        this.off("error", onError);
                    };
                    const afterCalc = (info) => {
                        if (calcKeys.delete(info.index.toString())) {
                            if (calcKeys.size === 0) {
                                resolve();
                                off();
                            }
                        }
                    };
                    const onError = () => {
                        reject();
                        off();
                    };
                    this.on("push", afterCalc);
                    this.once("error", onError);
                });
            } while (true);
            Object.freeze(this.list);
            /**
             * 这里只需要去做一个简单的返回操作就行
             * 并不是为了等待done的事件触发完成
             * 而只是确保异常能被正常捕捉
             */
            return this.emit("done", undefined);
        }
    }
    throw(err) {
        if (!this.is_done) {
            this._is_rejected = true;
            this._task?.reject(err);
            Object.freeze(this.list);
            /**
             * 这里只需要去做一个简单的返回操作就行
             * 并不是为了等待error的事件触发完成
             * 而只是确保异常能被正常捕捉
             */
            return this.emit("error", (this._reason = err));
        }
    }
    resolve() {
        return this.done();
    }
    reject(err) {
        return this.throw(err);
    }
    then(...args) {
        return this._initTask().then(...args);
    }
    catch(...args) {
        return this._initTask().catch(...args);
    }
    get requestProcess() {
        return this._requestProcess;
    }
    [Symbol.asyncIterator]() {
        const self = this;
        const { list, calcs } = self;
        return {
            index: 0,
            return() {
                $ignoreAwait(self.done());
                return Promise.resolve({ done: true, value: undefined });
            },
            async next() {
                const need_index = this.index;
                if (calcs[need_index]) {
                    $ignoreAwait(calcs[need_index]());
                }
                const value = list[need_index];
                let res = {
                    done: self.is_done,
                    value,
                };
                if (need_index in list) {
                    // 如果有值，那么一定还没结束
                    res.done = false;
                }
                else {
                    if (!self.is_done) {
                        res = await new Promise((resolve, reject) => {
                            const off_bind = () => {
                                self.off("error", wait_error);
                                self.off("push", wait_next);
                                self.off("pushCalc", wait_next_calc);
                                self.off("done", wait_done);
                            };
                            const wait_error = (err, next) => {
                                off_bind();
                                reject(err);
                                return next();
                            };
                            const wait_done = (_, next) => {
                                off_bind();
                                resolve({
                                    done: true,
                                    value,
                                });
                                return next();
                            };
                            const wait_next = ({ item, index }, next) => {
                                if (need_index === index) {
                                    off_bind();
                                    resolve({ done: false, value: item });
                                }
                                return next();
                            };
                            const wait_next_calc = ({ calc, index }, next) => {
                                if (need_index === index) {
                                    off_bind();
                                    resolve({ done: false, value: calc() });
                                }
                                return next();
                            };
                            self.on("error", wait_error);
                            self.on("done", wait_done);
                            self.on("push", wait_next);
                            self.on("pushCalc", wait_next_calc);
                            ///
                            try {
                                const res = self.emit("requestItem", (self._requestProcess = need_index));
                                res?.catch((err) => {
                                    self.emit("error", err);
                                });
                            }
                            catch (err) {
                                self.emit("error", err);
                            }
                        });
                        // res = {
                        //   // 列表中有值的话那就还没结束
                        //   done: self.is_done && !(need_index in list),
                        //   value,
                        // };
                    }
                }
                this.index += 1;
                return res;
            },
        };
    }
    toAsyncIterableIterator() {
        return AII(this);
    }
}
__decorate([
    bindThis,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", void 0)
], AsyncIteratorGenerator.prototype, "push", null);
__decorate([
    bindThis,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function, Object]),
    __metadata("design:returntype", void 0)
], AsyncIteratorGenerator.prototype, "pushCalc", null);
__decorate([
    bindThis,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AsyncIteratorGenerator.prototype, "done", null);
__decorate([
    bindThis,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], AsyncIteratorGenerator.prototype, "throw", null);
__decorate([
    bindThis,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], AsyncIteratorGenerator.prototype, "resolve", null);
__decorate([
    bindThis,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], AsyncIteratorGenerator.prototype, "reject", null);
__decorate([
    bindThis,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], AsyncIteratorGenerator.prototype, "then", null);
__decorate([
    bindThis,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], AsyncIteratorGenerator.prototype, "catch", null);
async function* AII(ag) {
    yield* ag;
}
/**
 * 管道转移工具，使用 filterMap 哲学
 * @param sourceAg
 * @param filter
 * @param map
 * @param destAg
 */
export const AsyncIteratorGeneratorTransfer = (sourceAg, destAg, filterMap) => {
    let reqNextPoList = [new PromiseOut()];
    const getPoAtList = (poList, index) => {
        let po = poList[index];
        if (po === undefined) {
            po = poList[index] = new PromiseOut();
        }
        return po;
    };
    const getPrAtIndex = (index) => {
        if (reqNextPoList === undefined) {
            return;
        }
        return getPoAtList(reqNextPoList, index).promise;
    };
    let yieldIndex = 0;
    /// source=>dest
    (async () => {
        /// 等待下一次请求的指令，如果没有指令，那么就冲到底
        await getPrAtIndex(yieldIndex);
        for await (const source of sourceAg) {
            let fm = filterMap(source);
            if (fm.async) {
                fm = await fm.value;
            }
            if (fm.filter) {
                if (fm.multi) {
                    for (const map of fm.maps) {
                        destAg.push(map);
                    }
                }
                else {
                    destAg.push(fm.map);
                }
                /// 等待下一次请求的指令，如果没有指令，那么就冲到底
                await getPrAtIndex(yieldIndex);
            }
        }
        await destAg.done();
    })().catch(destAg.throw);
    /// dest=>source
    destAg.on("done", (_, next) => (sourceAg.done(), next()));
    destAg.on("error", (err, next) => (sourceAg.throw(err), next()));
    destAg.on("requestItem", (_index, next) => {
        /// 这里使用内部自己维护的yieldIndex而不是index，因为destAg可能会被外部自定义push了一些数据，导致index偏差。
        /// 我们只需要准确地传递 for await 触发的次数就好了，只有阻塞的时候才会触发 requestItem，也只有阻塞的时候才需要从sourceAg那边拿数据
        if (reqNextPoList !== undefined) {
            getPoAtList(reqNextPoList, yieldIndex).resolve();
            yieldIndex += 1;
        }
        next();
    });
    destAg.on("requestAll", (_, next) => {
        if (reqNextPoList !== undefined) {
            for (const po of reqNextPoList) {
                if (po.is_resolved === false) {
                    po.resolve();
                }
            }
            reqNextPoList = undefined;
        }
        next();
    });
};
