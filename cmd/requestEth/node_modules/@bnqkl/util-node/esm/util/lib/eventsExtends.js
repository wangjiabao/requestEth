import { __decorate, __metadata } from "tslib";
import { cacheGetter } from "../../decorator/index.js";
import { EasyMap } from "../../extends-map/index.js";
export class EventsMap extends EasyMap {
    constructor(entries) {
        super((_eventname) => [], entries);
    }
    add(key, hanlder) {
        this.forceGet(key).push(hanlder);
    }
    remove(key, hanlder) {
        const events = this.get(key);
        if (events) {
            const index = events.indexOf(hanlder);
            if (index !== -1) {
                events.splice(index, 1);
                return true;
            }
        }
        return false;
    }
}
export function EventMapIsolation(eventEmitter) {
    const BINDED_EVENTS_MAP = new EventsMap();
    const on_isolation = (eventname, handler) => {
        eventEmitter.on(eventname, handler);
        BINDED_EVENTS_MAP.add(eventname, handler);
        return proxy;
    };
    const off_isolation = (eventname, handler) => {
        if (BINDED_EVENTS_MAP.remove(eventname, handler)) {
            eventEmitter.off(eventname, handler);
        }
        return proxy;
    };
    const once_isolation = (eventname, handler) => {
        const wrapperHandler = (...args) => {
            BINDED_EVENTS_MAP.remove(eventname, wrapperHandler);
            return handler(...args);
        };
        return on_isolation(eventname, wrapperHandler);
    };
    const clear_isolation = () => {
        for (const [eventname, hanlders] of BINDED_EVENTS_MAP) {
            for (const hanlder of hanlders) {
                eventEmitter.off(eventname, hanlder);
            }
        }
        BINDED_EVENTS_MAP.clear();
        return proxy;
    };
    const proxy = new Proxy(eventEmitter, {
        get(target, name, receiver) {
            if (name === "on" || name === "addListener") {
                return on_isolation;
            }
            if (name === "off" || name === "removeListener") {
                return off_isolation;
            }
            if (name === "once") {
                return once_isolation;
            }
            if (name === "removeAllListeners" || name === "clear") {
                return clear_isolation;
            }
            return Reflect.get(target, name, receiver);
        },
    });
    return proxy;
}
/**
 * 事件绑定隔离器
 * 在使用事件清除的时候（`off`,`clear`），能之清理有经过隔离器来进行绑定的事件
 */
export class EventCleanerIsolation {
    constructor(eventEmitter) {
        Object.defineProperty(this, "eventEmitter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: eventEmitter
        });
        Object.defineProperty(this, "BINDED_EVENTS_MAP", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new EventsMap()
        });
        //#endregion
        /**导出类型 */
        Object.defineProperty(this, "TYPE", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    on(eventname, handler, opts) {
        this.eventEmitter.on(eventname, handler, opts);
        this.BINDED_EVENTS_MAP.add(eventname, handler);
        return this;
    }
    off(eventname, handler) {
        if (this.BINDED_EVENTS_MAP.remove(eventname, handler)) {
            this.eventEmitter.off(eventname, handler);
        }
        return this;
    }
    emit(eventname, ...data) {
        this.eventEmitter.emit(eventname, ...data);
        return this;
    }
    once(eventname, handler, opts) {
        const wrapperHandler = (...args) => {
            this.BINDED_EVENTS_MAP.remove(eventname, wrapperHandler);
            return handler(...args);
        };
        this.BINDED_EVENTS_MAP.add(eventname, wrapperHandler);
        this.eventEmitter.once(eventname, handler, opts);
        return this;
    }
    removeAllListeners() {
        for (const [eventname, hanlders] of this.BINDED_EVENTS_MAP) {
            for (const hanlder of hanlders) {
                this.eventEmitter.off(eventname, hanlder);
            }
        }
        this.BINDED_EVENTS_MAP.clear();
        return this;
    }
    //#region 同名拓展
    get clear() {
        return this.removeAllListeners;
    }
    get addListener() {
        return this.on;
    }
    get removeListener() {
        return this.off;
    }
}
__decorate([
    cacheGetter,
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], EventCleanerIsolation.prototype, "clear", null);
__decorate([
    cacheGetter,
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], EventCleanerIsolation.prototype, "addListener", null);
__decorate([
    cacheGetter,
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], EventCleanerIsolation.prototype, "removeListener", null);
/**
 * 事件隔离绑定器
 * 针对`EventTarget`类型
 */
export class EventTargetCleanerIsolation {
    constructor(eventTarget) {
        Object.defineProperty(this, "eventTarget", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: eventTarget
        });
        Object.defineProperty(this, "BINDED_EVENTS_MAP", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new EventsMap()
        });
    }
    addEventListener(type, listener, options) {
        const res = this.eventTarget.addEventListener(type, listener, options);
        if (listener) {
            this.BINDED_EVENTS_MAP.add(type, listener);
        }
        return res;
    }
    dispatchEvent(event) {
        return this.eventTarget.dispatchEvent(event);
    }
    removeEventListener(type, callback, options) {
        const res = this.eventTarget.removeEventListener(type, callback, options);
        if (callback) {
            this.BINDED_EVENTS_MAP.remove(type, callback);
        }
    }
    clearAll() {
        for (const [eventname, hanlders] of this.BINDED_EVENTS_MAP) {
            for (const hanlder of hanlders) {
                this.eventTarget.removeEventListener(eventname, hanlder);
            }
        }
        this.BINDED_EVENTS_MAP.clear();
        return this;
    }
}
