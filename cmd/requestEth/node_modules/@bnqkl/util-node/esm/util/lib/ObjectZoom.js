export class ObjectZoom {
    constructor(_sort, useindex) {
        Object.defineProperty(this, "_sort", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _sort
        });
        Object.defineProperty(this, "useindex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: useindex
        });
        Object.defineProperty(this, "keysMaps", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "indexs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        if (useindex) {
            //   this.indexs_1_keyzoom = new ObjectZoom(["a", "b"]);
            useindex.forEach((index_keys, indexname) => {
                this.indexs.set(indexname, {
                    keyzoom: new ObjectZoom(index_keys),
                    valueRef: new Map(),
                });
            });
        }
    }
    fromObject(obj) {
        let res = null;
        if (!this._sort) {
            this._sort = Object.keys(obj);
        }
        let is_new_item = false;
        for (const key of this._sort) {
            let keyMap = this.keysMaps.get(key);
            if (!keyMap) {
                keyMap = new Map();
                this.keysMaps.set(key, keyMap);
            }
            const value = obj[key];
            //   console.log(key, value);
            const kres = keyMap.get(value);
            if (!kres) {
                is_new_item = true;
                res = Object.create(res);
                res[key] = value;
                keyMap.set(value, res);
            }
            else {
                res = kres;
            }
        }
        /// 保存索引
        if (is_new_item) {
            this.indexs.forEach((index) => {
                const indexKey = index.keyzoom.fromObject(res);
                let indexVal = index.valueRef.get(indexKey);
                if (!indexVal) {
                    indexVal = new Set();
                    index.valueRef.set(indexKey, indexVal);
                }
                indexVal.add(res);
            });
        }
        return res;
    }
}
// // const delegateObj = Object.create(null);
// // delegateObj.delegate = "delegate 1 address";
// // const delegateMap = new Map([[delegateObj.delegate, delegateObj]]);
// // const dappIdObj = Object.create(delegateObj);
// // dappIdObj.dappId = "myDappid";
// // const dappIdMap = new Map([[dappIdObj.dappId, dappIdObj]]);
// // const senderIdObj = Object.create(dappIdObj);
// // senderIdObj.senderId = "senderIdwzx";
// // const senderIdMap = new Map([[senderIdObj.senderId, senderIdObj]]);
// // const roundObj = Object.create(senderIdObj);
// // roundObj.round = 123;
// // const roundMap = new Map([[roundObj.round, roundObj]]);
// // console.log(JSON.stringify(roundObj,null,2));
// type VOTES = string[];
// const memVoteMemory = new Map<MyZOOM_OBJ, VOTES>();
// let votes = memVoteMemory.get(zobj_2);
// if (!votes) {
//   votes = [];
//   memVoteMemory.set(zobj_2, votes);
// }
// votes.push(Math.random().toString(16));
// console.log(memVoteMemory.get(zobj_2));
