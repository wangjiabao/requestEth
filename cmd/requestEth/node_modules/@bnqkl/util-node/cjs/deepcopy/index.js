"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepCopy = void 0;
const detector_js_1 = require("./detector.js");
const collection_js_1 = require("./collection.js");
const copier_js_1 = require("./copier.js");
/**
 * deepcopy function
 *
 * @param {*} value
 * @param {Object|Function} [options]
 * @return {*}
 */
function deepCopy(value, options = {}) {
    if (typeof options === "function") {
        options = {
            customizer: options,
        };
    }
    const { 
    // TODO: before/after customizer
    customizer,
    // TODO: max depth
    // depth = Infinity,
     } = options;
    const valueType = (0, detector_js_1.detectType)(value);
    if (!(0, collection_js_1.isCollection)(valueType)) {
        return (0, copier_js_1.copy)(value, valueType);
    }
    const copiedValue = (0, copier_js_1.copy)(value, valueType, customizer);
    const references = new WeakMap([[value, copiedValue]]);
    const visited = new WeakSet([value]);
    return recursiveCopy(value, copiedValue, references, visited, customizer);
}
exports.deepCopy = deepCopy;
/**
 * recursively copy
 *
 * @param {*} value target value
 * @param {*} clone clone of value
 * @param {WeakMap} references visited references of clone
 * @param {WeakSet} visited visited references of value
 * @param {Function} customizer user customize function
 * @return {*}
 */
function recursiveCopy(value, clone, references, visited, customizer) {
    const type = (0, detector_js_1.detectType)(value);
    const copiedValue = (0, copier_js_1.copy)(value, type);
    // return if not a collection value
    if (!(0, collection_js_1.isCollection)(type)) {
        return copiedValue;
    }
    let keys;
    switch (type) {
        case "Arguments":
        case "Array":
            keys = Object.keys(value);
            break;
        case "Object":
            keys = Object.keys(value).concat(Object.getOwnPropertySymbols(value));
            break;
        case "Map":
        case "Set":
            keys = value.keys();
            break;
        default:
    }
    // walk within collection with iterator
    if (keys) {
        for (const collectionKey of keys) {
            const collectionValue = (0, collection_js_1.get)(value, collectionKey, type);
            if (visited.has(collectionValue)) {
                // for [Circular]
                (0, collection_js_1.set)(clone, collectionKey, references.get(collectionValue), type);
            }
            else {
                const collectionValueType = (0, detector_js_1.detectType)(collectionValue);
                const copiedCollectionValue = (0, copier_js_1.copy)(collectionValue, collectionValueType, customizer);
                // save reference if value is collection
                if ((0, collection_js_1.isCollection)(collectionValueType)) {
                    references.set(collectionValue, copiedCollectionValue);
                    visited.add(collectionValue);
                }
                if (copiedCollectionValue)
                    (0, collection_js_1.set)(clone, collectionKey, Object.isFrozen(copiedCollectionValue)
                        ? copiedCollectionValue
                        : recursiveCopy(collectionValue, copiedCollectionValue, references, visited, customizer), type);
            }
        }
    }
    // TODO: isSealed/isFrozen/isExtensible
    return clone;
}
