"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapIterator = exports.mapAsyncIterator = exports.filterIterator = exports.filterAsyncIterator = exports.limitIterator = exports.limitAsyncIterator = exports.mixSortIterator = exports.mixSortAsyncIterator = void 0;
const tslib_1 = require("tslib");
tslib_1.__exportStar(require("../extends-iterator-is/index.js"), exports);
/**
 * 混合排序输出
 * @param iteratorA
 * @param iteratorB
 * @param compareFu
 */
async function* mixSortAsyncIterator(iteratorA, iteratorB, compareFu) {
    let itemAp = iteratorA.next();
    let itemA = itemAp instanceof Promise ? await itemAp : itemAp;
    let itemBp = iteratorB.next();
    let itemB = itemBp instanceof Promise ? await itemBp : itemBp;
    do {
        /// 如果混合排序完成，剩下的就是做最后的输出了
        if (itemB.done) {
            if (itemA.done) {
                break;
            }
            yield itemA.value;
            yield* iteratorA;
            break;
        }
        if (itemA.done) {
            yield itemB.value;
            yield* iteratorB;
            break;
        }
        /// 执行混合排序，返回一个值后就要进行迭代更新
        if (compareFu(itemA.value, itemB.value) >= 0) {
            /// 使用`>=` ，多了一个`===`的判定，优先返回内存对象
            yield itemA.value;
            itemAp = iteratorA.next();
            itemA = itemAp instanceof Promise ? await itemAp : itemAp;
        }
        else {
            yield itemB.value;
            itemBp = iteratorB.next();
            itemB = itemBp instanceof Promise ? await itemBp : itemBp;
        }
    } while (true);
}
exports.mixSortAsyncIterator = mixSortAsyncIterator;
/**
 * 混合排序输出
 * @param iteratorA
 * @param iteratorB
 * @param compareFu
 */
function* mixSortIterator(iteratorA, iteratorB, compareFu) {
    let itemA = iteratorA.next();
    let itemB = iteratorB.next();
    do {
        /// 如果混合排序完成，剩下的就是做最后的输出了
        if (itemB.done) {
            if (itemA.done) {
                break;
            }
            yield itemA.value;
            yield* iteratorA;
            break;
        }
        else if (itemA.done) {
            yield itemB.value;
            yield* iteratorB;
            break;
        }
        else {
            /// 执行混合排序，返回一个值后就要进行迭代更新
            if (compareFu(itemA.value, itemB.value) >= 0) {
                /// 使用`>=` ，多了一个`===`的判定，优先返回内存对象
                yield itemA.value;
                itemA = iteratorA.next();
            }
            else {
                yield itemB.value;
                itemB = iteratorB.next();
            }
        }
    } while (true);
}
exports.mixSortIterator = mixSortIterator;
/**
 * 对迭代器的结果进行了长度约束
 * @param iteratorSource
 * @param limitOpts
 */
async function* limitAsyncIterator(iteratorSource, limitOpts) {
    const { limit, tryKeepAborter } = limitOpts;
    let yieldedCount = 0;
    let preAccount;
    for await (const account of iteratorSource) {
        /**前置判断 */
        if (yieldedCount >= limit) {
            if (tryKeepAborter(account, preAccount)) {
                /// 中断判断
                break;
            }
        }
        yieldedCount += 1;
        yield (preAccount = account);
        /**后置判断 */
        if (yieldedCount >= limit) {
            /// 如果需要获取更多，那么就将break交给前置判断
            if (!tryKeepAborter) {
                break;
            }
        }
    }
}
exports.limitAsyncIterator = limitAsyncIterator;
/**
 * 对迭代器的结果进行了长度约束
 * @param iteratorSource
 * @param limitOpts
 */
function* limitIterator(iteratorSource, limitOpts) {
    const { limit, tryKeepAborter } = limitOpts;
    let yieldedCount = 0;
    let preAccount;
    for (const account of iteratorSource) {
        /**前置判断 */
        if (yieldedCount >= limit) {
            if (tryKeepAborter(account, preAccount)) {
                /// 中断判断
                break;
            }
        }
        yieldedCount += 1;
        yield (preAccount = account);
        /**后置判断 */
        if (yieldedCount >= limit) {
            /// 如果需要获取更多，那么就将break交给前置判断
            if (!tryKeepAborter) {
                break;
            }
        }
    }
}
exports.limitIterator = limitIterator;
/**
 * 过滤迭代器的结果
 * @param iteratorSource
 * @param mapper
 */
async function* filterAsyncIterator(iteratorSource, filter) {
    for await (const item of iteratorSource) {
        if (filter(item)) {
            yield item;
        }
    }
}
exports.filterAsyncIterator = filterAsyncIterator;
/**
 * 过滤迭代器的结果
 * @param iteratorSource
 * @param mapper
 */
function* filterIterator(iteratorSource, filter) {
    for (const item of iteratorSource) {
        if (filter(item)) {
            yield item;
        }
    }
}
exports.filterIterator = filterIterator;
/**
 * 转换迭代器的输出
 * @param iteratorSource
 * @param mapper
 */
async function* mapAsyncIterator(iteratorSource, mapper) {
    for await (const item of iteratorSource) {
        yield mapper(item);
    }
}
exports.mapAsyncIterator = mapAsyncIterator;
/**
 * 转换迭代器的输出
 * @param iteratorSource
 * @param mapper
 */
function* mapIterator(iteratorSource, mapper) {
    for (const item of iteratorSource) {
        yield mapper(item);
    }
}
exports.mapIterator = mapIterator;
