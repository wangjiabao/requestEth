"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.quene = exports.FunctionQuener = void 0;
const index_js_1 = require("../typings/index.js");
class SimplePromiseOut {
    constructor() {
        Object.defineProperty(this, "resolve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "reject", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "promise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Promise((resolve, reject) => {
                this.resolve = resolve;
                this.reject = reject;
            })
        });
    }
}
const simpleSleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
/**
 * 纯函数版的 quene
 * @param sourceFun
 * @param opts
 */
function FunctionQuener(sourceFun, opts = {}) {
    const { bounceTime, argsMerger } = opts;
    /**当前正在执行的任务 */
    let _taskLock;
    /**队列中的任务 */
    let _inQueneTask;
    async function loopDoTask(_this, args) {
        do {
            const lock = _taskLock;
            if (!lock) {
                return;
            }
            try {
                const startTime = Date.now();
                lock.resolve((await sourceFun.apply(_this, args)));
                if (bounceTime) {
                    const restTime = bounceTime - (Date.now() - startTime);
                    if (restTime > 1) {
                        await simpleSleep(restTime);
                    }
                }
            }
            catch (err) {
                lock.reject(err);
            }
            finally {
                _taskLock = undefined;
                /// 如果当前有排队的任务在等待执行，那么执行这个队列
                if (_inQueneTask) {
                    _taskLock = _inQueneTask.lock;
                    args = _inQueneTask.args;
                    _inQueneTask = undefined;
                }
            }
        } while (true);
    }
    function functionQuened(...args) {
        /// 如果当前有任务在执行，添加一个合并的任务队列
        if (_taskLock) {
            /// 放置一个队列
            if (!_inQueneTask) {
                _inQueneTask = { lock: new SimplePromiseOut(), args };
            }
            else {
                _inQueneTask.args = argsMerger
                    ? argsMerger(args, _inQueneTask.args)
                    : args;
            }
            return _inQueneTask.lock.promise;
        }
        // 自行加锁
        _taskLock = new SimplePromiseOut();
        /// 开始循环执行任务
        (0, index_js_1.$ignoreAwait)(loopDoTask(this, args));
        return _taskLock.promise;
    }
    Object.defineProperty(functionQuened, "source_fun", {
        value: sourceFun,
        writable: false,
        configurable: false,
        enumerable: false,
    });
    return functionQuened;
}
exports.FunctionQuener = FunctionQuener;
/**
 * 用做修饰器版的 quene
 * @param opts
 */
function quene(opts = {}) {
    return function queneInner(target, propertyKey, descriptor) {
        if (!descriptor || typeof descriptor.value !== "function") {
            throw new TypeError(`Only methods can be decorated with @quene. <${propertyKey}> is not a method!`);
        }
        const res = {
            configurable: true,
            value: FunctionQuener(descriptor.value, opts),
            enumerable: descriptor.enumerable,
        };
        return res;
    };
}
exports.quene = quene;
// class B {
//   @quene<B, "say">({
//     argsMerger(newArgs, oldArgs) {
//       return [oldArgs[0] + " " + newArgs[0]];
//     },
//   })
//   async say(word: string) {
//     await new Promise((resolve) => setTimeout(resolve, 100));
//     console.log(word);
//   }
// }
// const b = new B();
// b.say("I");
// b.say("love");
// b.say("you!");
// const a = FunctionQuener(() => {
//   return Promise.resolve(1);
// });
