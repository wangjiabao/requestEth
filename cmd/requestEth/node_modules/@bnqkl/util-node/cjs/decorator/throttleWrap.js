"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.throttleWrap = exports.THROTTLE_WRAP_PLOT = void 0;
const index_js_1 = require("../typings/index.js");
/**队列策略 */
var THROTTLE_WRAP_PLOT;
(function (THROTTLE_WRAP_PLOT) {
    /**等待任务执行完成才开始下一个任务 */
    THROTTLE_WRAP_PLOT[THROTTLE_WRAP_PLOT["WAIT_RESULT_RETURN"] = 0] = "WAIT_RESULT_RETURN";
    /**不等待任务执行完成，只要一开始执行，就能开始执行下一个任务 */
    THROTTLE_WRAP_PLOT[THROTTLE_WRAP_PLOT["NO_WAIT_EXEC_TIME"] = 1] = "NO_WAIT_EXEC_TIME";
})(THROTTLE_WRAP_PLOT = exports.THROTTLE_WRAP_PLOT || (exports.THROTTLE_WRAP_PLOT = {}));
/**
 *
 * @param ms
 */
function throttleWrap(ms = 1000, plot = THROTTLE_WRAP_PLOT.WAIT_RESULT_RETURN) {
    return (target, name, descriptor) => {
        const source_fun = descriptor.value;
        let run_lock;
        descriptor.value = async function lock(...args) {
            if (run_lock) {
                run_lock = new Promise((resolve, reject) => {
                    setTimeout(() => {
                        const res = source_fun.apply(this, args);
                        if (plot === THROTTLE_WRAP_PLOT.WAIT_RESULT_RETURN) {
                            (0, index_js_1.$ignoreAwait)(res.then(resolve, reject).finally(() => {
                                run_lock = undefined;
                            }));
                        }
                        else if (plot === THROTTLE_WRAP_PLOT.NO_WAIT_EXEC_TIME) {
                            resolve(res);
                            run_lock = undefined;
                        }
                        else {
                            throw new SyntaxError(`No support throttleWrap plot:${THROTTLE_WRAP_PLOT.NO_WAIT_EXEC_TIME}`);
                        }
                    }, ms);
                });
            }
            return run_lock;
        };
        descriptor.value.source_fun = source_fun;
        return descriptor;
    };
}
exports.throttleWrap = throttleWrap;
