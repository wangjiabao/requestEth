"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.INJECTPROP_ONINIT_MATE_KEY = exports.INJECTPROP_AFERTINIT_MATE_KEY = exports.getInstanceModules = exports.beforeCreateInstanceModuleStrogeStack = exports.INSTANCE_MODULES_WM = exports.FACTORY_CUSTOM_INJECT_MODULE_MAP = exports.GROUP_TOKEN_SYMNOL = exports.SINGLETON_TOKEN_SYMNOL = exports.INJECTION_TOKEN_SYMNOL = void 0;
/**用于标识可注入依赖模块名字的Symbol标识 */
exports.INJECTION_TOKEN_SYMNOL = Symbol("InjectionToken");
/**用于标记模块是单利模式的Symbol标识 */
exports.SINGLETON_TOKEN_SYMNOL = Symbol("SingletonToken");
/**用于标记模块是插件模式的Symbol标识 */
exports.GROUP_TOKEN_SYMNOL = Symbol("GroupToken");
/**
 * 存储构造函数的`@Inject`修饰信息
 * 可以让构造函数在初始化的时候将特定的依赖进行注入
 */
exports.FACTORY_CUSTOM_INJECT_MODULE_MAP = new WeakMap();
/**
 * 对象与其ModelStroge的映射
 */
exports.INSTANCE_MODULES_WM = new WeakMap();
/**
 * 对象在实例化的过程中，因为还没有正式return出来
 * 所以就还没有在`INSTANCE_MODULES_WM`中建立映射
 * 这里就使用调用堆栈的形式来进行临时保存
 * 这样在需要在使用`InjectProp`创建getter的时候，不会因为马上需要`ModuleStroge`而又因为实例对象还没建立好映射而导致问题
 */
exports.beforeCreateInstanceModuleStrogeStack = [];
function getInstanceModules(ins) {
    return (exports.INSTANCE_MODULES_WM.get(ins) ||
        exports.beforeCreateInstanceModuleStrogeStack[exports.beforeCreateInstanceModuleStrogeStack.length - 1]);
}
exports.getInstanceModules = getInstanceModules;
exports.INJECTPROP_AFERTINIT_MATE_KEY = "injectProps:afertInit";
exports.INJECTPROP_ONINIT_MATE_KEY = "injectProps:onInit";
