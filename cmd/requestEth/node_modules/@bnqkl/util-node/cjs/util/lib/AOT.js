"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AOT_Placeholder = exports.AOT = void 0;
/**用于将一些函数在运行的过程中，跳过一些固有的等待条件，使得运行更快*/
class AOT {
    constructor(id = "anonymous", default_condition = false) {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: id
        });
        /**JIT运行时的条件属性*/
        Object.defineProperty(this, "condition", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**是否进行静态链接*/
        Object.defineProperty(this, "compile_into", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        this.condition = default_condition;
    }
    autoRegister(target) {
        const aot_flags = AOT_Placeholder.GetAOTFlags(target);
        if (!aot_flags) {
            return;
        }
        for (const aot_flag of aot_flags) {
            if (aot_flag.type === "Then") {
                const then_data = aot_flag.data;
                this.register(target, then_data.prop_name, this.Then(then_data.then_fun_name));
            }
            else if (aot_flag.type === "Wait") {
                const wait_data = aot_flag.data;
                this.register(target, wait_data.prop_name, this.Wait(wait_data.condition_promise_fun_name, wait_data.skip_if_false));
            }
        }
    }
    _getPropDescriptor(target, name) {
        let proto = target;
        do {
            if (proto.hasOwnProperty(name)) {
                return Object.getOwnPropertyDescriptor(proto, name);
            }
            proto = Object.getPrototypeOf(proto);
            if (!proto) {
                break;
            }
        } while (true);
    }
    register(target, name, declaration) {
        const des = this._getPropDescriptor(target, name);
        if (des) {
            Object.defineProperty(target, name, declaration(target, name, des));
        }
    }
    /**条件语句*/
    Then(then_fun_name) {
        const self = this;
        return (target, name, des) => {
            const source_fun = des.value;
            des.value = function (...args) {
                const { condition } = self;
                if (self.compile_into) {
                    this[name] = condition ? this[then_fun_name] : source_fun;
                }
                if (condition) {
                    return this[then_fun_name](...args);
                }
                else {
                    return source_fun.apply(this, args);
                }
            };
            des.value.source_fun = source_fun;
            return des;
        };
    }
    /**前置条件*/
    Wait(condition_promise_fun_name, skip_if_false = false) {
        const self = this;
        return (target, name, des) => {
            const source_fun = des.value;
            des.value = function (...args) {
                const { condition } = self;
                if (self.compile_into) {
                    if (!condition) {
                        console.warn(`[${self.id}]`, "AOT-Wait's condition must be true");
                    }
                    this[name] = source_fun;
                }
                else {
                    console.warn(`[${self.id}]`, `JIT mode run ${name}`);
                }
                if (!condition) {
                    // 在条件不成立的时候，需要始终进行条件判断的等待
                    const condition = this[condition_promise_fun_name];
                    return (condition instanceof Function
                        ? this[condition_promise_fun_name](...args)
                        : Promise.resolve(condition)).then((pre_condition_res) => {
                        if (skip_if_false && !pre_condition_res) {
                            return;
                        }
                        return source_fun.apply(this, args);
                    });
                }
                else {
                    return source_fun.apply(this, args);
                }
            };
            des.value.source_fun = source_fun;
            return des;
        };
    }
    compile(condition) {
        if (this.compile_into) {
            return false;
        }
        this.condition = condition;
        return (this.compile_into = true);
    }
}
exports.AOT = AOT;
const AOT_FLAGS_CACHE = new WeakMap();
class AOT_Placeholder {
    static GetAOTFlags(target) {
        const aot_flags = [];
        let proto = target;
        do {
            const _flags = AOT_FLAGS_CACHE.get(proto);
            if (_flags) {
                aot_flags.push(..._flags);
            }
            proto = Object.getPrototypeOf(proto);
            if (!proto) {
                break;
            }
        } while (true);
        return aot_flags;
    }
    static GetAndSetAOTFlags(target) {
        let aot_flags = AOT_FLAGS_CACHE.get(target);
        if (!aot_flags) {
            aot_flags = [];
            AOT_FLAGS_CACHE.set(target, aot_flags);
        }
        return aot_flags;
    }
    static Then(then_fun_name) {
        return (target, name, des) => {
            this.GetAndSetAOTFlags(target).push({
                type: "Then",
                data: { then_fun_name, prop_name: name },
            });
            return des;
        };
    }
    static Wait(condition_promise_fun_name, skip_if_false = false) {
        return (target, name, des) => {
            this.GetAndSetAOTFlags(target).push({
                type: "Wait",
                data: { condition_promise_fun_name, skip_if_false, prop_name: name },
            });
            return des;
        };
    }
}
exports.AOT_Placeholder = AOT_Placeholder;
