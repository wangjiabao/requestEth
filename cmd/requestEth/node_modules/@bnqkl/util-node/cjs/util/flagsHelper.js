"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FLAG_INJECTION_PARAM = exports.FlagsHelper = exports.FlagParamStack = void 0;
const tslib_1 = require("tslib");
const index_js_1 = require("../dep_inject/index.js");
let FlagParamStack = class FlagParamStack {
    constructor() {
        Object.defineProperty(this, "_instanceParamWM", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new WeakMap()
        });
    }
    getParam(ins) {
        return this._instanceParamWM.get(ins);
    }
    setParam(ins, v) {
        this._instanceParamWM.set(ins, v);
    }
};
FlagParamStack = tslib_1.__decorate([
    (0, index_js_1.Injectable)()
], FlagParamStack);
exports.FlagParamStack = FlagParamStack;
const QuotedStringReg = /"(?:\.|(\\\")|[^\""\n])*"|'(?:\.|(\\\')|[^\''\n])*'/g;
let FlagsHelper = class FlagsHelper {
    constructor(moduleMap, flagParamStack) {
        Object.defineProperty(this, "moduleMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: moduleMap
        });
        Object.defineProperty(this, "flagParamStack", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: flagParamStack
        });
        Object.defineProperty(this, "_applyedFlagMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "_flagInfomationMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    strToBool_(value) {
        const valueLower = value.toLowerCase();
        if (valueLower === "disable" ||
            valueLower === "disabled" ||
            valueLower === "false") {
            return false;
        }
        if (valueLower === "enable" ||
            valueLower === "enabled" ||
            valueLower === "true" ||
            valueLower === "") {
            return true;
        }
        return value;
    }
    _formatString(value) {
        if ((value.startsWith("'") && value.endsWith("'")) ||
            (value.startsWith('"') && value.endsWith('"'))) {
            return value.slice(1, -1);
        }
        return value;
    }
    /**
     * 参数解析
     */
    parse(flags) {
        const stringValueCache = [];
        const stringPlaceholder = `_PLACE_${Math.random()
            .toString(36)
            .slice(2)}_HOLDER_`;
        const flagList = flags
            .replace(QuotedStringReg, (m) => {
            stringValueCache.push(m);
            return stringPlaceholder;
        })
            .split(/\s+/)
            .filter((flag) => !!flag);
        const flagMap = new Map();
        for (const flag of flagList) {
            const equal = flag.indexOf("=");
            let key;
            let param = "";
            let value;
            if (equal === -1) {
                key = flag;
            }
            else {
                key = flag.substr(0, equal);
                if (key.includes(stringPlaceholder)) {
                    throw new Error(`Flags format error: ${key.replace(stringPlaceholder, stringValueCache.shift() || stringPlaceholder)} is invilde.`);
                }
                param = flag
                    .substr(equal + 1)
                    .replace(new RegExp(stringPlaceholder, "g"), (ph) => {
                    const sourceStr = stringValueCache.shift();
                    if (!sourceStr) {
                        throw new Error();
                    }
                    return sourceStr;
                });
            }
            const flagInfo = this._flagInfomationMap.get(flag);
            if (flagInfo) {
                switch (flagInfo.type) {
                    case "boolean":
                        value = Boolean(this.strToBool_(param));
                        break;
                    case "number":
                        const numParam = Number.parseFloat(param);
                        if (Number.isNaN(numParam)) {
                            value = undefined;
                        }
                        else {
                            value = numParam;
                        }
                        break;
                    case "string":
                        value = this._formatString(param);
                        break;
                }
            }
            else {
                /// try to bool
                value = this.strToBool_(param);
                /// try to num
                if (typeof value === "string") {
                    const numberMayby = parseFloat(value);
                    if (numberMayby.toString() === value) {
                        value = numberMayby;
                    }
                }
                /// try to string
                if (typeof value === "string") {
                    value = this._formatString(value);
                }
            }
            /// 先进行移除再进行赋值，确保顺序是跟着覆盖的值的位置
            flagMap.delete(key);
            flagMap.set(key, value);
        }
        return flagMap;
    }
    quote(flagMap) {
        const flags = [];
        for (let [key, value] of flagMap) {
            if (value === undefined) {
                flags.push(key);
            }
            else {
                if (typeof value === "string") {
                    value = JSON.stringify(value);
                }
                flags.push(`${key}=${value}`);
            }
        }
        return flags.join(" ");
    }
    /**
     * 应用参数，触发注册的回调
     * @param flags
     */
    applyFlags(flags) {
        if (!(flags instanceof Map)) {
            flags = this.parse(flags);
        }
        for (const [flag, value] of flags) {
            this.setFlagValue(flag, value);
        }
        return (this._applyedFlagMap = flags);
    }
    getFlagValue(flag) {
        return this._applyedFlagMap.get(flag);
    }
    setFlagValue(flag, value) {
        const flagInfo = this._flagInfomationMap.get(flag);
        if (flagInfo) {
            if (value === false) {
                if (flagInfo.onDisable instanceof Function) {
                    flagInfo.onDisable();
                }
                this._applyedFlagMap.delete(flag);
            }
            else {
                if (flagInfo.onEnable instanceof Function) {
                    flagInfo.onEnable(value);
                }
                this._applyedFlagMap.set(flag, value);
            }
            return true;
        }
        return false;
    }
    hasFlag(flag) {
        return this._applyedFlagMap.has(flag);
    }
    getApplyedFlags() {
        return this.quote(this._applyedFlagMap);
    }
    registerBooleanFlag(flag, onEnable, onDisable) {
        if (this._flagInfomationMap.has(flag)) {
            throw new Error(`Duplicate registration boolean flag: ${flag}.`);
        }
        this._flagInfomationMap.set(flag, {
            type: "boolean",
            onEnable,
            onDisable,
        });
    }
    registerStringFlag(flag, onEnable, onDisable) {
        if (this._flagInfomationMap.has(flag)) {
            throw new Error(`Duplicate registration string flag: ${flag}.`);
        }
        this._flagInfomationMap.set(flag, {
            type: "string",
            onEnable,
            onDisable,
        });
    }
    registerNumberFlag(flag, onEnable, onDisable) {
        if (this._flagInfomationMap.has(flag)) {
            throw new Error(`Duplicate registration number flag: ${flag}.`);
        }
        this._flagInfomationMap.set(flag, {
            type: "number",
            onEnable,
            onDisable,
        });
    }
    registerInjectionFlag(flag, ModuleFactory, type = "boolean") {
        if (this._flagInfomationMap.has(flag)) {
            throw new Error(`Duplicate registration injection flag: ${flag}.`);
        }
        this._flagInfomationMap.set(flag, {
            type,
            onEnable: (v) => {
                const moduleMap = this.moduleMap;
                const ins = (0, index_js_1.Resolve)(ModuleFactory, moduleMap.installMask(new index_js_1.ModuleStroge([[exports.FLAG_INJECTION_PARAM, v]])));
                this.flagParamStack.setParam(ins, v);
            },
        });
    }
};
FlagsHelper = tslib_1.__decorate([
    (0, index_js_1.Injectable)(),
    tslib_1.__metadata("design:paramtypes", [index_js_1.ModuleStroge,
        FlagParamStack])
], FlagsHelper);
exports.FlagsHelper = FlagsHelper;
/**
 * 专门用于构造函数的临时flag
 */
exports.FLAG_INJECTION_PARAM = Symbol("flag param in constructor");
