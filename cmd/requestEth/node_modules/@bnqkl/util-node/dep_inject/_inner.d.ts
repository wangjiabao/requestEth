import { $Constructor } from "../typings/$types.js";
import { $FactoryCustomInjectModule } from "./$types.js";
import type { ModuleStroge } from "./ModuleStroge.js";
/**用于标识可注入依赖模块名字的Symbol标识 */
export declare const INJECTION_TOKEN_SYMNOL: unique symbol;
/**用于标记模块是单利模式的Symbol标识 */
export declare const SINGLETON_TOKEN_SYMNOL: unique symbol;
/**用于标记模块是插件模式的Symbol标识 */
export declare const GROUP_TOKEN_SYMNOL: unique symbol;
/**
 * 存储构造函数的`@Inject`修饰信息
 * 可以让构造函数在初始化的时候将特定的依赖进行注入
 */
export declare const FACTORY_CUSTOM_INJECT_MODULE_MAP: WeakMap<$Constructor<any>, $FactoryCustomInjectModule>;
/**
 * 对象与其ModelStroge的映射
 */
export declare const INSTANCE_MODULES_WM: WeakMap<any, ModuleStroge>;
/**
 * 对象在实例化的过程中，因为还没有正式return出来
 * 所以就还没有在`INSTANCE_MODULES_WM`中建立映射
 * 这里就使用调用堆栈的形式来进行临时保存
 * 这样在需要在使用`InjectProp`创建getter的时候，不会因为马上需要`ModuleStroge`而又因为实例对象还没建立好映射而导致问题
 */
export declare const beforeCreateInstanceModuleStrogeStack: ModuleStroge[];
export declare function getInstanceModules(ins: any): ModuleStroge;
export declare const INJECTPROP_AFERTINIT_MATE_KEY = "injectProps:afertInit";
export declare const INJECTPROP_ONINIT_MATE_KEY = "injectProps:onInit";
