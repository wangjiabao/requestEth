import { $Constructor } from "../typings/$types.js";
import { $MODULE_ID_TYPE, $InjectModuleConfig } from "./$types.js";
/**
 * 主动要求注入的模块
 * 如果我们依赖的是一个`Interface`，那么这种情况没有可用的构造函数可以让我们使用`@Injectable`去修饰模块
 * 这时候就必须在主动地声明依赖的名称，并在使用`Resolve`初始化的时候将对于的模块注入
 *
 * 也可以配合`@Injectable`实现依赖反转
 *
 * @param module_name
 */
export declare function Inject(inject_module?: $MODULE_ID_TYPE | $Constructor<object>, conf?: $InjectModuleConfig): (target: any, prop_name: string, index?: number | PropertyDescriptor) => void;
/**
 * 脏注入。
 * 一般用于模块循环依赖时，不建议使用，建议梳理清楚项目结构
 * @param inject_module_getter
 * @param conf
 * @returns
 */
export declare function DirtyInjectProp(inject_module_getter: () => $MODULE_ID_TYPE | $Constructor<object>, conf?: $InjectModuleConfig): (target: any, prop_name: string, des?: PropertyDescriptor) => void;
export declare const enum AUTO_RESOLVE_PLOT {
    NO_RESOLVE = 0,
    ON_GETTER = 1,
    ON_INIT = 2,
    AFTER_INIT = 3
}
export declare function InjectProp(inject_module: $MODULE_ID_TYPE | $Constructor<object>, conf?: $InjectModuleConfig): (target: any, prop_name: string, des?: PropertyDescriptor) => void;
