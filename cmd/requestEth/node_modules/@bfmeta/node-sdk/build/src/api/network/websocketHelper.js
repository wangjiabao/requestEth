"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebsocketHelper = void 0;
const tslib_1 = require("tslib");
const io = tslib_1.__importStar(require("socket.io-client"));
const baseUtil_1 = require("../../helpers/baseUtil");
const constants_1 = require("../../constants");
const promiseOut_1 = require("../../helpers/promiseOut");
class WebsocketHelper {
    __configHelper;
    __config;
    REQUEST_PROTOCOL = "websocket";
    URL_PREFIX = ``;
    TRANSACTION_SERVER_URL_PREFIX;
    constructor(configHelper) {
        this.__configHelper = configHelper;
        this.__config = this.__configHelper.apiConfig;
        this.TRANSACTION_SERVER_URL_PREFIX = `http://127.0.0.1:${this.__config.transactionServerPort}`;
        this.__init().catch((e) => { });
    }
    __getUrl(args) {
        return `http://${args.ip}:${args.port}`;
    }
    __getWebsocketHost(url) {
        return `${url}/systemChannel`;
    }
    __socketMap = new Map();
    __initPromise = new promiseOut_1.PromiseOut();
    async __init() {
        try {
            const { node, multiNodes } = this.__config;
            const taskList = [];
            if (node) {
                const url = this.__getUrl(node);
                if (!this.__socketMap.has(url)) {
                    taskList.push(this.connect(url));
                }
            }
            if (multiNodes && multiNodes.enable) {
                const { nodes } = multiNodes;
                for (const node of nodes) {
                    const url = this.__getUrl(node);
                    if (!this.__socketMap.has(url)) {
                        taskList.push(this.connect(url));
                    }
                }
            }
            await Promise.all(taskList);
            this.__initPromise.resolve();
        }
        catch (error) {
        }
        finally {
            await (0, baseUtil_1.sleep)(30 * 1000);
        }
    }
    __connect(url) {
        return new Promise((resolve, reject) => {
            const wsHost = this.__getWebsocketHost(url);
            const socket = io.connect(wsHost, {
                transports: ["websocket"],
                timeout: this.__config.requestTimeOut,
                transportOptions: {
                    websocket: {
                        maxPayload: constants_1.maxOneFileSize,
                    },
                },
            });
            socket.on("connect", () => {
                console.debug(`connected to ${url}`);
                this.__socketMap.set(url, socket);
                this.__initPromise.resolve();
                return resolve(socket);
            });
            socket.on("connect_error", (data) => {
                return reject(new Error(`connect_error ${url} data:${data}`));
            });
            socket.on("connect_timeout", (data) => {
                return reject(new Error(`connect_timeout ${url} data:${data}`));
            });
        });
    }
    __bindEvent(socket, url) {
        socket.on("reconnect_error", (data) => {
            throw Error(`reconnect_error ${url} data:${data}`);
        });
        socket.on("error", (data) => {
            throw Error(`error ${url} data:${data}`);
        });
        socket.on("disconnect", () => {
            this.__socketMap.delete(url);
        });
    }
    async connect(url) {
        try {
            const socket = await this.__connect(url);
            this.__bindEvent(socket, url);
            this.__socketMap.set(url, socket);
        }
        catch (error) {
            console.debug(error.message || error);
        }
    }
    getSocket() {
        if (this.__socketMap.size === 0) {
            return undefined;
        }
        const sockets = [...this.__socketMap.values()];
        return sockets[Math.floor(Math.random() * sockets.length)];
    }
    createTransaction(url, argv) {
        return new Promise(async (resolve, reject) => {
            let timeoutId;
            try {
                timeoutId = setTimeout(() => {
                    clearTimeout(timeoutId);
                    reject(new Error(`request timeout ${url}`));
                }, this.__config.requestTimeOut);
                await this.__initPromise.promise;
                const socket = this.getSocket();
                if (!socket) {
                    return reject(new Error(`no nodes available`));
                }
                socket.emit(url, argv, (result) => {
                    clearTimeout(timeoutId);
                    return resolve(result);
                });
            }
            catch (e) {
                clearTimeout(timeoutId);
                return reject(e);
            }
        });
    }
    async sendGetRequest(url, argv) {
        return new Promise(async (resolve, reject) => {
            let timeoutId;
            try {
                timeoutId = setTimeout(() => {
                    clearTimeout(timeoutId);
                    reject(new Error(`request timeout ${url}`));
                }, this.__config.requestTimeOut);
                await this.__initPromise.promise;
                const socket = this.getSocket();
                if (!socket) {
                    return reject(new Error(`no nodes available`));
                }
                socket.emit(url, argv, (result) => {
                    clearTimeout(timeoutId);
                    return resolve(result);
                });
            }
            catch (e) {
                clearTimeout(timeoutId);
                return reject(e);
            }
        });
    }
    sendPostRequest = this.createTransaction;
    getSocketByNode(node) {
        return this.__socketMap.get(this.__getUrl(node));
    }
    __upgradeSocket;
    get upgradeSocket() {
        return this.__upgradeSocket;
    }
    async sendUpgradeRequest(url, argv) {
        return new Promise(async (resolve, reject) => {
            let timeoutId;
            try {
                timeoutId = setTimeout(() => {
                    clearTimeout(timeoutId);
                    reject(new Error(`request timeout ${url}`));
                }, this.__config.requestTimeOut);
                let socket;
                if (this.upgradeSocket) {
                    socket = this.upgradeSocket;
                }
                else {
                    socket = await this.__initUpgrade();
                }
                socket.emit(url, argv, (result) => {
                    clearTimeout(timeoutId);
                    return resolve(result);
                });
            }
            catch (e) {
                clearTimeout(timeoutId);
                return reject(e);
            }
        });
    }
    __initUpgrade() {
        const node = this.__config.node;
        if (node && node.upgradePort) {
            const wsHost = `ws://${node.ip}:${node.upgradePort}`;
            return new Promise((resolve, reject) => {
                const socket = io.connect(wsHost, {
                    transports: ["websocket"],
                    timeout: this.__config.requestTimeOut,
                    transportOptions: {
                        websocket: {
                            maxPayload: constants_1.maxOneFileSize,
                        },
                    },
                });
                socket.on("connect", () => {
                    console.debug(`connected to ${wsHost}`);
                    this.__upgradeSocket = socket;
                    return resolve(socket);
                });
                socket.on("connect_error", (data) => {
                    this.__upgradeSocket = undefined;
                    return reject(new Error(`${wsHost} connect_error`));
                });
                socket.on("connect_timeout", (data) => {
                    this.__upgradeSocket = undefined;
                    return reject(new Error(`${wsHost} connect_timeout`));
                });
                socket.on("reconnect_attempt", (data) => {
                    return reject(new Error(`${wsHost} reconnect_attempt`));
                });
                socket.on("reconnect_error", (data) => {
                    this.__upgradeSocket = undefined;
                    return reject(new Error(`${wsHost} reconnect_error`));
                });
                socket.on("error", (data) => {
                    this.__upgradeSocket = undefined;
                    return reject(new Error(`${wsHost} error`));
                });
                socket.on("close", (data) => {
                    this.__upgradeSocket = undefined;
                    return reject(new Error(`${wsHost} close`));
                });
                socket.on("disconnect", () => {
                    this.__upgradeSocket = undefined;
                    return reject(new Error(`${wsHost} disconnected`));
                });
            });
        }
        else {
            throw new Error(`upgradePort: ${JSON.stringify(node)} is not init`);
        }
    }
}
exports.WebsocketHelper = WebsocketHelper;
