export declare class BFMetaSignUtil {
    private __prefix;
    private __buffer;
    private __keypairHelper;
    private __cryptoHelper;
    private __base58Helper;
    constructor(prefix: string, buffer: BFMetaSignUtil.Buffer.BufferConstructor, cryptoHelper: BFMetaSignUtil.CryptoHelperInterface);
    /**
     * 判断地址是否符合规范
     * @param address 地址
     */
    isAddress(address: any): Promise<boolean>;
    /**
     * 生成公私钥对
     *
     * @param secret
     * @returns
     */
    createKeypair(secret: string): Promise<{
        secretKey: BFMetaSignUtil.Buffer.Buffer;
        publicKey: BFMetaSignUtil.Buffer.Buffer;
    }>;
    /**
     * 根据私钥生成公私钥对
     *
     * @param secretKey
     * @returns
     */
    createKeypairBySecretKey(secretKey: Uint8Array): {
        secretKey: BFMetaSignUtil.Buffer.Buffer;
        publicKey: BFMetaSignUtil.Buffer.Buffer;
    };
    /**
     * 根据私钥生成公私钥对
     *
     * @param secretKey
     * @returns
     */
    createKeypairBySecretKeyString(secretKey: string): {
        secretKey: BFMetaSignUtil.Buffer.Buffer;
        publicKey: BFMetaSignUtil.Buffer.Buffer;
    };
    /**
     * 获取公钥
     *
     * @param secret
     * @returns
     */
    getPublicKeyFromSecret(secret: string): Promise<string>;
    /**
     * 根据公钥（Uint8Array）生成地址的二进制数据
     *
     * @param publicKey
     * @returns
     */
    getBinaryAddressFromPublicKey(publicKey: Uint8Array): Promise<BFMetaSignUtil.Buffer.Buffer>;
    /**
     * 根据公钥 （Uint8Array） 生成地址（base58）
     *
     * @param publicKey
     * @param prefix
     * @returns
     */
    getAddressFromPublicKey(publicKey: Uint8Array, prefix?: string): Promise<string>;
    /**
     * 根据 公钥（hex） 生成地址（base58）
     *
     * @param publicKey
     * @param prefix
     * @returns
     */
    getAddressFromPublicKeyString(publicKey: string, prefix?: string): Promise<string>;
    /**
     * 根据主密码生成地址
     *
     * @param secret
     * @returns
     */
    getAddressFromSecret(secret: string): Promise<string>;
    /**
     * 根据主密码和二次密码生成密钥对
     *
     * @param secret 主密码
     * @param secondSecret 安全密码
     */
    createSecondKeypair(secret: string, secondSecret: string): Promise<{
        secretKey: BFMetaSignUtil.Buffer.Buffer;
        publicKey: BFMetaSignUtil.Buffer.Buffer;
    }>;
    /**
     * 获取安全公钥
     * @param secret
     * @param secondSecret
     * @returns
     */
    getSecondPublicKeyFromSecretAndSecondSecret(secret: string, secondSecret: string): Promise<BFMetaSignUtil.Buffer.Buffer>;
    /**
     * 根据私钥获取公钥String
     *
     * @param secret
     * @param secondSecret
     * @param encode
     * @returns
     */
    getSecondPublicKeyStringFromSecretAndSecondSecret(secret: string, secondSecret: string, encode?: string): Promise<string>;
    /**
     * 校验二次密码公钥是否正确
     * @param secret 主密码
     * @param secondSecret 二次密码
     * @param secondPublicKey 二次密码公钥
     */
    checkSecondSecret(secret: string, secondSecret: string, secondPublicKey: string): Promise<boolean>;
    /**
     * 根据安全密码的公私钥对
     *
     * @param secret
     * @param secondSecret
     * @returns
     */
    createSecondKeypairV2(secret: string, secondSecret: string): Promise<{
        secretKey: BFMetaSignUtil.Buffer.Buffer;
        publicKey: BFMetaSignUtil.Buffer.Buffer;
    }>;
    /**
     * 获取安全公钥
     * @param secret
     * @param secondSecret
     * @returns
     */
    getSecondPublicKeyFromSecretAndSecondSecretV2(secret: string, secondSecret: string): Promise<BFMetaSignUtil.Buffer.Buffer>;
    /**
     * 根据私钥获取公钥String
     *
     * @param secret
     * @param secondSecret
     * @param encode
     * @returns
     */
    getSecondPublicKeyStringFromSecretAndSecondSecretV2(secret: string, secondSecret: string, encode?: string): Promise<string>;
    /**
     * 校验二次密码公钥是否正确
     * @param secret 主密码
     * @param secondSecret 二次密码
     * @param secondPublicKey 二次密码公钥
     */
    checkSecondSecretV2(secret: string, secondSecret: string, secondPublicKey: string): Promise<boolean>;
    /**
     * 根据主密码和二次密码生成密钥对 -- 已弃用
     *
     * 这里虽然用了md5,当因为sha256后,所以还算安全,不过也许可以换一种更加友好的方式
     *
     * @param secret 主密码
     * @param secondSecret 安全密码
     */
    createSecondKeypairDeprecated(secret: string, secondSecret: string): Promise<{
        secretKey: BFMetaSignUtil.Buffer.Buffer;
        publicKey: BFMetaSignUtil.Buffer.Buffer;
    }>;
    /**
     * 获取安全公钥 -- 已弃用
     * @param secret
     * @param secondSecret
     * @returns
     */
    getSecondPublicKeyFromSecretAndSecondSecretDeprecated(secret: string, secondSecret: string): Promise<BFMetaSignUtil.Buffer.Buffer>;
    /**
     * 根据私钥获取公钥String -- 已弃用
     *
     * @param secret
     * @param secondSecret
     * @param encode
     * @returns
     */
    getSecondPublicKeyStringFromSecretAndSecondSecretDeprecated(secret: string, secondSecret: string, encode?: string): Promise<string>;
    /**
     * 校验二次密码公钥是否正确 -- 已弃用
     * @param secret 主密码
     * @param secondSecret 二次密码
     * @param secondPublicKey 二次密码公钥
     */
    checkSecondSecretDeprecated(secret: string, secondSecret: string, secondPublicKey: string): Promise<boolean>;
    /**
     * 签名
     *
     * @param keypair
     * @param hash
     */
    detachedSign(message: Uint8Array, secretKey: Uint8Array): Promise<BFMetaSignUtil.Buffer.Buffer>;
    /**
     * 验证签名
     *
     * @param message
     * @param signatureBuffer
     * @param publicKeyBuffer
     * @returns
     */
    detachedVeriy(message: Uint8Array, signatureBuffer: Uint8Array, publicKeyBuffer: Uint8Array): Promise<boolean>;
    /**
     * 签名并且转成 hex 字符串
     *
     * @param message
     * @param secretKey
     * @returns
     */
    signToString(message: Uint8Array, secretKey: Uint8Array): Promise<string>;
    /**
     * 非对称加密
     *
     * @param msg
     * @param decryptPK
     * @param encryptSK
     */
    asymmetricEncrypt(msg: Uint8Array, decryptPK: Uint8Array, encryptSK: Uint8Array): {
        encryptedMessage: Uint8Array;
        nonce: Uint8Array;
    };
    /**
     * 非对称解密
     *
     * @param encryptedMessage
     * @param nonce
     * @param encryptPK
     * @param decryptSK
     */
    asymmetricDecrypt(encryptedMessage: Uint8Array, encryptPK: Uint8Array, decryptSK: Uint8Array, nonce?: Uint8Array): false | Uint8Array;
}
//# sourceMappingURL=bfmetaSignUtil.d.ts.map