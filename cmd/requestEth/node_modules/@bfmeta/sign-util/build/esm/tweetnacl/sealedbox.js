"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sealedbox_open = exports.sealedbox = void 0;
const array_1 = require("./array");
const box_1 = require("./box");
const blake2b_1 = require("./blake2b");
function sealedbox(m, pk) {
    const c = new array_1.ByteArray(48 /* SealedBoxLength.Overhead */ + m.length);
    const ek = (0, box_1.box_keyPair)();
    c.set(ek.publicKey);
    const nonce = nonce_gen(ek.publicKey, pk);
    const boxed = (0, box_1.box)(m, nonce, pk, ek.secretKey);
    c.set(boxed, ek.publicKey.length);
    // clear secret key
    for (let i = 0; i < ek.secretKey.length; i++)
        ek.secretKey[i] = 0;
    return c;
}
exports.sealedbox = sealedbox;
function sealedbox_open(c, pk, sk) {
    if (c.length < 48 /* SealedBoxLength.Overhead */)
        return;
    const epk = c.subarray(0, 32 /* SealedBoxLength.PublicKey */);
    const nonce = nonce_gen(epk, pk);
    const boxData = c.subarray(32 /* SealedBoxLength.PublicKey */);
    return (0, box_1.box_open)(boxData, nonce, epk, sk);
}
exports.sealedbox_open = sealedbox_open;
function nonce_gen(pk1, pk2) {
    const state = (0, blake2b_1.blake2b_init)(24 /* SealedBoxLength.Nonce */);
    (0, blake2b_1.blake2b_update)(state, pk1);
    (0, blake2b_1.blake2b_update)(state, pk2);
    return (0, blake2b_1.blake2b_final)(state);
}
//# sourceMappingURL=sealedbox.js.map