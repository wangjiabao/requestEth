"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PeerListHelper = exports.PeerListHelperParmas = void 0;
const util_node_1 = require("@bnqkl/util-node");
const constants_1 = require("./constants");
exports.PeerListHelperParmas = {
    checkInterval: Symbol("checkInterval"),
};
let PeerListHelper = class PeerListHelper {
    checkInterval;
    customerPeerCheckHelperInterface;
    logger;
    __peersConfig = [];
    get peersConfig() {
        return this.__peersConfig;
    }
    set peersConfig(p) {
        this.__peersConfig = p;
    }
    __initPromiseOut = new util_node_1.PromiseOut();
    constructor(checkInterval, customerPeerCheckHelperInterface, logger) {
        this.checkInterval = checkInterval;
        this.customerPeerCheckHelperInterface = customerPeerCheckHelperInterface;
        this.logger = logger;
    }
    async init() {
        do {
            for (const peerConfig of this.peersConfig) {
                const p = {
                    ip: peerConfig.ip,
                    port: peerConfig.port,
                    protocol: peerConfig.protocol,
                    enable: false,
                    delay: Infinity,
                };
                const peer = await this.__checkStatusByPeer(p);
                if (peer.enable) {
                    this.peerMap.set(`${p.ip}:${p.port}`, peer);
                }
            }
            this.__enablePeerArr = [...this.peerMap.values()].sort((a, b) => a.delay - b.delay);
            // 第一次初始化后 将锁释放
            if (!this.__initPromiseOut.is_finished) {
                this.__initPromiseOut.resolve(undefined);
            }
            await (0, util_node_1.sleep)(this.checkInterval);
        } while (true);
    }
    peerMap = new Map();
    __enablePeerArr = [];
    async checkPeerInterval() {
        do {
            const _tempArr = [];
            for (const [key, peer] of this.peerMap.entries()) {
                let p = await this.__checkStatusByPeer(peer);
                if (p.enable) {
                    _tempArr.push(p);
                }
            }
            this.__enablePeerArr = _tempArr.sort((a, b) => a.delay - b.delay);
            await (0, util_node_1.sleep)(this.checkInterval);
        } while (true);
    }
    async __checkStatusByPeer(peer) {
        try {
            const delay = await this.customerPeerCheckHelperInterface.checkStatusByPeer(peer);
            peer.delay = delay;
            peer.enable = true;
            return peer;
        }
        catch (err) {
            peer.enable = false;
            peer.delay = Infinity;
            this.logger.warn(err);
            return peer;
        }
    }
    /** @TODO 以下两个接口要做一些缓存策略 */
    async getEnableRandom() {
        await this.__initPromiseOut.promise;
        if (this.__enablePeerArr.length > 0) {
            return this.__enablePeerArr[Math.floor(Math.random() * this.__enablePeerArr.length)];
        }
        else {
            throw new Error(`can not find enable peer`);
        }
    }
    async getEnablePeerByDelay() {
        await this.__initPromiseOut.promise;
        if (this.__enablePeerArr.length > 0) {
            return this.__enablePeerArr[0];
        }
        else {
            throw new Error(`can not find enable peer`);
        }
    }
};
PeerListHelper = __decorate([
    (0, util_node_1.Injectable)(),
    __param(0, (0, util_node_1.Inject)(exports.PeerListHelperParmas.checkInterval)),
    __param(1, (0, util_node_1.Inject)("CustomerPeerCheckHelper")),
    __param(2, (0, util_node_1.Inject)(constants_1.LoggerSymbol)),
    __metadata("design:paramtypes", [Number, Object, Object])
], PeerListHelper);
exports.PeerListHelper = PeerListHelper;
